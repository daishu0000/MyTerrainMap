# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MyTerrainMapDialog
                                 A QGIS plugin
 Create Terrain Map
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-01-13
        git sha              : $Format:%H$
        copyright            : (C) 2025 by daishu
        email                : daishu10000@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import json
from osm2geojson import json2geojson
import tempfile

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import (
    QgsVectorLayer,
    QgsRasterLayer,
    QgsProject,
    QgsSingleBandPseudoColorRenderer,
    QgsStyle,
    QgsSingleBandGrayRenderer
)

import os
import processing

import requests

import pydevd_pycharm

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MyTerrainMap_dialog_base.ui'))


class MyTerrainMapDialog(QtWidgets.QDialog, FORM_CLASS):

    folder_path="E://mytry"
    def __init__(self, parent=None):
        """Constructor."""
        super(MyTerrainMapDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.pbGet.clicked.connect(self.onPbGetClicked)

    def onPbGetClicked(self):
        # # 其中的'localhost'和port是在Python Debug Server中填写的值
        # pydevd_pycharm.settrace('localhost', port=53100, stdoutToServer=True, stderrToServer=True)

        apiKey=self.edAPIKey.text()
        name=self.edName.text()
        adminLevel=self.spAdminLevel.value()
        # 验证输入
        if not name.strip():
            print("请输入有效的地名")
            return

        # Overpass API 查询
        query = f"""
        [out:json];
        (
          relation["name"="{name}"]["admin_level"={adminLevel}];
        );
        out body;
        >;
        out skel qt;
        """
        url = "https://overpass-api.de/api/interpreter"
        try:
            print("正在下载数据...")
            response = requests.post(url, data={"data": query})
            response.raise_for_status()  # 检查 HTTP 错误

            # 将返回的 JSON 加载为 QGIS 图层
            osm_json = json.loads(response.text)

            if osm_json["elements"]:

                geojson_data = json2geojson(osm_json)

                # 提取第一个 feature
                geojson_data = {
                    "type": "FeatureCollection",
                    "features": [geojson_data["features"][0]]
                }

                geojson_data = json.dumps(geojson_data, indent=2, ensure_ascii=False)  # 设置 ensure_ascii=False 以支持中文字符

                geojson_file_path = self.folder_path+"//"+name+".geojson"
                with open(geojson_file_path, "w", encoding="utf-8") as file:
                    file.write(geojson_data)

                # 加载保存的 GeoJSON 文件到地图
                layer = QgsVectorLayer(geojson_file_path, "My Layer", "ogr")

                if layer.isValid():
                    pass
                    # 将图层添加到当前QGIS项目
                    # QgsProject.instance().addMapLayer(layer)
                else:
                    print("图层无效")
                    return
                extent = layer.extent()

                dem_path = self.download_srtm_dem(extent,apiKey,name)
                clip_path=self.clip_dem_with_layer(dem_path, geojson_file_path,name)
                self.saveImg(clip_path)

            else:
                print("没有满足条件要素")
                return




        except requests.exceptions.RequestException as e:
            print(f"下载失败: {e}")

        return

    def download_srtm_dem(self,extent, apiKey,name):
        """
        下载 SRTM 30m DEM 数据
        :param extent: QgsRectangle，范围对象，包含 xmin, ymin, xmax, ymax
        :param apiKey: OpenTopography API 密钥
        :param save_path: 保存 DEM 文件的路径
        """
        # 获取范围坐标
        xmin = extent.xMinimum()
        ymin = extent.yMinimum()
        xmax = extent.xMaximum()
        ymax = extent.yMaximum()

        # 构建 API 请求参数
        url = "https://portal.opentopography.org/API/globaldem"
        params = {
            "demtype": "SRTMGL1",  # SRTM 30m DEM
            "south": ymin,
            "north": ymax,
            "west": xmin,
            "east": xmax,
            "outputFormat": "GTiff",  # GeoTIFF 格式
            "API_Key": apiKey
        }

        try:
            print("正在下载 DEM 数据...")
            response = requests.get(url, params=params, stream=True)
            response.raise_for_status()  # 检查 HTTP 请求是否成功

            # # 创建临时文件存储 DEM 数据
            # temp_dir = tempfile.gettempdir()
            # temp_file_path = os.path.join(temp_dir, "srtm_dem.tif")
            #
            # # 保存下载的 DEM 数据到临时文件
            # with open(temp_file_path, 'wb') as f:
            #     for chunk in response.iter_content(chunk_size=8192):
            #         f.write(chunk)
            #
            # print(f"DEM 数据已保存到 {temp_file_path}")


            dem_file_path = self.folder_path+"//"+name+".tif"
            with open(dem_file_path, "wb") as file:
                for chunk in response.iter_content(chunk_size=8192):
                    file.write(chunk)


            # 将 DEM 数据加载为 QGIS 临时图层
            layer_name = "SRTM DEM"
            raster_layer = QgsRasterLayer(dem_file_path, layer_name)

            if raster_layer.isValid():
                # QgsProject.instance().addMapLayer(raster_layer)
                # print(f"已将 DEM 图层加载到 QGIS 地图：{layer_name}")
                return dem_file_path
            else:
                print("加载 DEM 图层失败，请检查文件格式和内容。")


        except requests.exceptions.RequestException as e:
            print(f"下载失败: {e}")

    def clip_dem_with_layer(self, dem_path, vector_path,name):
        """
        使用矢量图层裁剪 DEM
        :param dem_path: DEM 栅格路径
        :param vector_layer: 裁剪的矢量图层
        """
        print(f"DEM Path: {dem_path}, Exists: {os.path.exists(dem_path)}")
        print(f"Vector Path: {vector_path}, Exists: {os.path.exists(vector_path)}")
        try:
            print("正在裁剪 DEM 数据...")
            # 裁剪的输出文件路径
            # temp_dir = tempfile.gettempdir()
            # output_path = os.path.join(temp_dir, "clipped_dem.tif")

            output_path = self.folder_path+"//"+name+"_clip.tif"

            # 调用 GDAL 裁剪工具
            params = {
                'INPUT': dem_path,
                'MASK': vector_path,
                'OUTPUT': output_path
            }

            processing.run("gdal:cliprasterbymasklayer", params)

            # 加载裁剪后的 DEM 图层
            clipped_layer = QgsRasterLayer(output_path, "Clipped DEM")
            if clipped_layer.isValid():
                return output_path
            else:
                print("裁剪后的 DEM 图层无效")

        except Exception as e:
            print(f"裁剪失败: {e}")

    def saveImg(self,dem_path):


        # 加载DEM文件
        dem_layer = QgsRasterLayer(dem_path, "DEM Layer")

        if not dem_layer.isValid():
            print("Failed to load the DEM layer!")
            return

        # 添加DEM图层到QGIS项目
        QgsProject.instance().addMapLayer(dem_layer)


        self.saveImg2(dem_path)


    def saveImg2(self,dem_path):
        from qgis.core import QgsRasterLayer, QgsRasterShader, QgsColorRampShader, QgsGradientColorRamp, \
            QgsSingleBandPseudoColorRenderer
        from qgis.PyQt.QtGui import QColor

        # 加载栅格图层
        raster_layer = QgsRasterLayer(dem_path, '伪彩色图层')

        if not raster_layer.isValid():
            print("Failed to load the raster layer!")
        else:
            # 创建栅格渲染器
            shader = QgsRasterShader()

            # 创建渐变色带（这里定义了蓝色、绿色、黄色和红色的渐变）
            color_ramp = QgsGradientColorRamp(QColor(0, 0, 255), QColor(255, 0, 0))  # 从蓝色到红色渐变

            # 设置颜色范围
            ramp_shader = QgsColorRampShader()
            ramp_shader.setSourceColorRamp(color_ramp)
            ramp_shader.setMinimumValue(0)  # 设置最小值
            ramp_shader.setMaximumValue(1000)  # 设置最大值
            shader.setRasterShaderFunction(ramp_shader)

            # 创建伪彩色渲染器
            renderer = QgsSingleBandPseudoColorRenderer(raster_layer.dataProvider(), 1, shader)

            # 应用渲染器
            raster_layer.setRenderer(renderer)

            # 刷新图层显示
            raster_layer.triggerRepaint()

            # 将图层添加到地图中
            QgsProject.instance().addMapLayer(raster_layer)







